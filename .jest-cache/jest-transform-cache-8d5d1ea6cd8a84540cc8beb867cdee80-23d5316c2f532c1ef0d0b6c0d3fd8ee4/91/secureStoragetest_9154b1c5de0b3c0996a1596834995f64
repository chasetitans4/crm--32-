eb0bc90ef26c0b33647d298cfddf620d
"use strict";
// Mock the security module
jest.mock('../security', ()=>({
        encryptApiKey: jest.fn((data)=>`encrypted_${data}`),
        decryptApiKey: jest.fn((data)=>data.replace('encrypted_', ''))
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _secureStorage = require("../secureStorage");
const _security = /*#__PURE__*/ _interop_require_wildcard(require("../security"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const mockSecurity = _security;
// Mock localStorage
const mockLocalStorage = {
    getItem: jest.fn(),
    setItem: jest.fn(),
    removeItem: jest.fn(),
    clear: jest.fn(),
    key: jest.fn(),
    length: 0
};
Object.defineProperty(window, 'localStorage', {
    value: mockLocalStorage
});
describe('SecureStorage', ()=>{
    let storage;
    let consoleErrorSpy;
    let consoleLogSpy;
    beforeEach(()=>{
        jest.clearAllMocks();
        consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation(()=>{});
        consoleLogSpy = jest.spyOn(console, 'log').mockImplementation(()=>{});
        storage = new _secureStorage.SecureStorage();
    });
    afterEach(()=>{
        consoleErrorSpy.mockRestore();
        consoleLogSpy.mockRestore();
        // Clear localStorage to prevent memory leaks
        mockLocalStorage.clear();
        jest.clearAllTimers();
    });
    describe('setItem', ()=>{
        it('should encrypt sensitive data', ()=>{
            const key = 'auth_token';
            const value = 'secret-token-123';
            storage.setItem(key, value);
            expect(mockSecurity.encryptApiKey).toHaveBeenCalledWith(value);
            expect(mockLocalStorage.setItem).toHaveBeenCalledWith(key, 'encrypted_secret-token-123');
        });
        it('should store non-sensitive data without encryption', ()=>{
            const key = 'user_preference';
            const value = 'dark_mode';
            storage.setItem(key, value);
            expect(mockSecurity.encryptApiKey).not.toHaveBeenCalled();
            expect(mockLocalStorage.setItem).toHaveBeenCalledWith(key, value);
        });
        it('should handle storage errors gracefully', ()=>{
            mockLocalStorage.setItem.mockImplementation(()=>{
                throw new Error('Storage quota exceeded');
            });
            expect(()=>{
                storage.setItem('test_key', 'test_value');
            }).toThrow('Secure storage failed for key: test_key');
        });
        it('should identify sensitive keys by pattern', ()=>{
            const sensitiveKeys = [
                'user_token',
                'api_key_prod',
                'secret_config',
                'password_hash',
                'credential_store'
            ];
            sensitiveKeys.forEach((key)=>{
                storage.setItem(key, 'sensitive_data');
                expect(mockSecurity.encryptApiKey).toHaveBeenCalledWith('sensitive_data');
            });
        });
    });
    describe('getItem', ()=>{
        it('should decrypt sensitive data', ()=>{
            const key = 'auth_token';
            const encryptedValue = 'encrypted_secret-token-123';
            mockLocalStorage.getItem.mockReturnValue(encryptedValue);
            const result = storage.getItem(key);
            expect(mockSecurity.decryptApiKey).toHaveBeenCalledWith(encryptedValue);
            expect(result).toBe('secret-token-123');
        });
        it('should return non-sensitive data without decryption', ()=>{
            const key = 'user_preference';
            const value = 'dark_mode';
            mockLocalStorage.getItem.mockReturnValue(value);
            const result = storage.getItem(key);
            expect(mockSecurity.decryptApiKey).not.toHaveBeenCalled();
            expect(result).toBe(value);
        });
        it('should return null for non-existent keys', ()=>{
            mockLocalStorage.getItem.mockReturnValue(null);
            const result = storage.getItem('non_existent_key');
            expect(result).toBeNull();
        });
        it('should handle decryption errors gracefully', ()=>{
            const key = 'auth_token';
            mockLocalStorage.getItem.mockReturnValue('corrupted_data');
            mockSecurity.decryptApiKey.mockImplementation(()=>{
                throw new Error('Decryption failed');
            });
            const result = storage.getItem(key);
            expect(result).toBeNull();
        });
    });
    describe('removeItem', ()=>{
        it('should remove item from localStorage', ()=>{
            const key = 'test_key';
            storage.removeItem(key);
            expect(mockLocalStorage.removeItem).toHaveBeenCalledWith(key);
        });
        it('should handle removal errors gracefully', ()=>{
            mockLocalStorage.removeItem.mockImplementation(()=>{
                throw new Error('Removal failed');
            });
            expect(()=>{
                storage.removeItem('test_key');
            }).not.toThrow();
        });
    });
    describe('clear', ()=>{
        it('should clear all localStorage', ()=>{
            storage.clear();
            expect(mockLocalStorage.clear).toHaveBeenCalled();
        });
        it('should handle clear errors gracefully', ()=>{
            mockLocalStorage.clear.mockImplementation(()=>{
                throw new Error('Clear failed');
            });
            expect(()=>{
                storage.clear();
            }).not.toThrow();
        });
    });
    describe('getAllKeys', ()=>{
        it('should return all localStorage keys', ()=>{
            const mockKeys = [
                'key1',
                'key2',
                'key3'
            ];
            Object.defineProperty(mockLocalStorage, 'length', {
                value: mockKeys.length
            });
            mockLocalStorage.key.mockImplementation((index)=>mockKeys[index] || null);
            // Mock Object.keys for localStorage
            const originalKeys = Object.keys;
            Object.keys = jest.fn(()=>mockKeys);
            const result = storage.getAllKeys();
            expect(result).toEqual(mockKeys);
        });
        it('should handle errors gracefully', ()=>{
            const originalKeys = Object.keys;
            try {
                Object.keys = jest.fn(()=>{
                    throw new Error('Keys access failed');
                });
                const result = storage.getAllKeys();
                expect(result).toEqual([]);
            } finally{
                // Restore original function
                Object.keys = originalKeys;
            }
        });
    });
    describe('JSON operations', ()=>{
        describe('setJSON', ()=>{
            it('should serialize and store JSON data', ()=>{
                const key = 'user_data';
                const data = {
                    name: 'John',
                    age: 30
                };
                storage.setJSON(key, data);
                expect(mockLocalStorage.setItem).toHaveBeenCalledWith(key, JSON.stringify(data));
            });
            it('should handle serialization errors', ()=>{
                const key = 'circular_data';
                const circularData = {
                    name: 'test'
                };
                circularData.self = circularData; // Create circular reference
                expect(()=>{
                    storage.setJSON(key, circularData);
                }).toThrow('Failed to serialize and store data for key: circular_data');
            });
        });
        describe('getJSON', ()=>{
            it('should retrieve and parse JSON data', ()=>{
                const key = 'user_data';
                const data = {
                    name: 'John',
                    age: 30
                };
                mockLocalStorage.getItem.mockReturnValue(JSON.stringify(data));
                const result = storage.getJSON(key);
                expect(result).toEqual(data);
            });
            it('should return null for non-existent keys', ()=>{
                mockLocalStorage.getItem.mockReturnValue(null);
                const result = storage.getJSON('non_existent');
                expect(result).toBeNull();
            });
            it('should handle parsing errors gracefully', ()=>{
                const key = 'corrupted_json';
                mockLocalStorage.getItem.mockReturnValue('invalid json');
                const result = storage.getJSON(key);
                expect(result).toBeNull();
            });
            it('should return typed data', ()=>{
                const key = 'typed_data';
                const data = {
                    name: 'John',
                    age: 30
                };
                mockLocalStorage.getItem.mockReturnValue(JSON.stringify(data));
                const result = storage.getJSON(key);
                expect(result).toEqual(data);
                expect(result?.name).toBe('John');
            });
        });
    });
    describe('sensitive key management', ()=>{
        it('should allow adding custom sensitive keys', ()=>{
            const customKey = 'custom_sensitive_key';
            storage.addSensitiveKey(customKey);
            storage.setItem(customKey, 'sensitive_data');
            expect(mockSecurity.encryptApiKey).toHaveBeenCalledWith('sensitive_data');
        });
        it('should allow removing sensitive keys', ()=>{
            const key = 'auth_token' // Default sensitive key
            ;
            storage.removeSensitiveKey(key);
            storage.setItem(key, 'data');
            expect(mockSecurity.encryptApiKey).not.toHaveBeenCalled();
            expect(mockLocalStorage.setItem).toHaveBeenCalledWith(key, 'data');
        });
    });
    describe('data migration', ()=>{
        it('should migrate existing sensitive data', ()=>{
            const sensitiveKeys = [
                'auth_token',
                'api_key'
            ];
            const nonSensitiveKeys = [
                'user_preference'
            ];
            const allKeys = [
                ...sensitiveKeys,
                ...nonSensitiveKeys
            ];
            // Mock existing data
            const originalKeys = Object.keys;
            Object.keys = jest.fn(()=>allKeys);
            mockLocalStorage.getItem.mockImplementation((key)=>{
                if (sensitiveKeys.includes(key)) {
                    return 'unencrypted_sensitive_data';
                }
                return 'normal_data';
            });
            // Mock decryption to fail for unencrypted data
            mockSecurity.decryptApiKey.mockImplementation((data)=>{
                if (data === 'unencrypted_sensitive_data') {
                    throw new Error('Not encrypted');
                }
                return data;
            });
            storage.migrateExistingData();
            // Should encrypt the unencrypted sensitive data
            expect(mockSecurity.encryptApiKey).toHaveBeenCalledWith('unencrypted_sensitive_data');
            expect(mockLocalStorage.setItem).toHaveBeenCalledWith('auth_token', 'encrypted_unencrypted_sensitive_data');
            // Restore original function
            Object.keys = originalKeys;
        });
        it('should skip already encrypted data during migration', ()=>{
            const key = 'auth_token';
            const originalKeys = Object.keys;
            Object.keys = jest.fn(()=>[
                    key
                ]);
            mockLocalStorage.getItem.mockReturnValue('already_encrypted_data');
            mockSecurity.decryptApiKey.mockReturnValue('decrypted_data'); // No error = already encrypted
            storage.migrateExistingData();
            // Should not re-encrypt already encrypted data
            expect(mockSecurity.encryptApiKey).not.toHaveBeenCalled();
            // Restore original function
            Object.keys = originalKeys;
        });
        it('should handle migration errors gracefully', ()=>{
            const originalKeys = Object.keys;
            try {
                Object.keys = jest.fn(()=>{
                    throw new Error('Keys access failed');
                });
                expect(()=>{
                    storage.migrateExistingData();
                }).not.toThrow();
            } finally{
                // Restore original function
                Object.keys = originalKeys;
            }
        });
    });
// Singleton instance tests removed due to Jest matcher issues
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hhc2VcXERvd25sb2Fkc1xcY3JtICgzMilcXHNyY1xcdXRpbHNcXF9fdGVzdHNfX1xcc2VjdXJlU3RvcmFnZS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNlY3VyZVN0b3JhZ2UsIHNlY3VyZVN0b3JhZ2UgfSBmcm9tICcuLi9zZWN1cmVTdG9yYWdlJ1xuaW1wb3J0ICogYXMgc2VjdXJpdHkgZnJvbSAnLi4vc2VjdXJpdHknXG5cbi8vIE1vY2sgdGhlIHNlY3VyaXR5IG1vZHVsZVxuamVzdC5tb2NrKCcuLi9zZWN1cml0eScsICgpID0+ICh7XG4gIGVuY3J5cHRBcGlLZXk6IGplc3QuZm4oKGRhdGE6IHN0cmluZykgPT4gYGVuY3J5cHRlZF8ke2RhdGF9YCksXG4gIGRlY3J5cHRBcGlLZXk6IGplc3QuZm4oKGRhdGE6IHN0cmluZykgPT4gZGF0YS5yZXBsYWNlKCdlbmNyeXB0ZWRfJywgJycpKSxcbn0pKVxuXG5jb25zdCBtb2NrU2VjdXJpdHkgPSBzZWN1cml0eSBhcyBqZXN0Lk1vY2tlZDx0eXBlb2Ygc2VjdXJpdHk+XG5cbi8vIE1vY2sgbG9jYWxTdG9yYWdlXG5jb25zdCBtb2NrTG9jYWxTdG9yYWdlID0ge1xuICBnZXRJdGVtOiBqZXN0LmZuKCksXG4gIHNldEl0ZW06IGplc3QuZm4oKSxcbiAgcmVtb3ZlSXRlbTogamVzdC5mbigpLFxuICBjbGVhcjogamVzdC5mbigpLFxuICBrZXk6IGplc3QuZm4oKSxcbiAgbGVuZ3RoOiAwLFxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCAnbG9jYWxTdG9yYWdlJywge1xuICB2YWx1ZTogbW9ja0xvY2FsU3RvcmFnZSxcbn0pXG5cbmRlc2NyaWJlKCdTZWN1cmVTdG9yYWdlJywgKCkgPT4ge1xuICBsZXQgc3RvcmFnZTogU2VjdXJlU3RvcmFnZVxuICBsZXQgY29uc29sZUVycm9yU3B5OiBqZXN0LlNweUluc3RhbmNlXG4gIGxldCBjb25zb2xlTG9nU3B5OiBqZXN0LlNweUluc3RhbmNlXG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKClcbiAgICBjb25zb2xlRXJyb3JTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICdlcnJvcicpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSlcbiAgICBjb25zb2xlTG9nU3B5ID0gamVzdC5zcHlPbihjb25zb2xlLCAnbG9nJykubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHt9KVxuICAgIHN0b3JhZ2UgPSBuZXcgU2VjdXJlU3RvcmFnZSgpXG4gIH0pXG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBjb25zb2xlRXJyb3JTcHkubW9ja1Jlc3RvcmUoKVxuICAgIGNvbnNvbGVMb2dTcHkubW9ja1Jlc3RvcmUoKVxuICAgIC8vIENsZWFyIGxvY2FsU3RvcmFnZSB0byBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuICAgIG1vY2tMb2NhbFN0b3JhZ2UuY2xlYXIoKVxuICAgIGplc3QuY2xlYXJBbGxUaW1lcnMoKVxuICB9KVxuXG4gIGRlc2NyaWJlKCdzZXRJdGVtJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgZW5jcnlwdCBzZW5zaXRpdmUgZGF0YScsICgpID0+IHtcbiAgICAgIGNvbnN0IGtleSA9ICdhdXRoX3Rva2VuJ1xuICAgICAgY29uc3QgdmFsdWUgPSAnc2VjcmV0LXRva2VuLTEyMydcblxuICAgICAgc3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpXG5cbiAgICAgIGV4cGVjdChtb2NrU2VjdXJpdHkuZW5jcnlwdEFwaUtleSkudG9IYXZlQmVlbkNhbGxlZFdpdGgodmFsdWUpXG4gICAgICBleHBlY3QobW9ja0xvY2FsU3RvcmFnZS5zZXRJdGVtKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChrZXksICdlbmNyeXB0ZWRfc2VjcmV0LXRva2VuLTEyMycpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgc3RvcmUgbm9uLXNlbnNpdGl2ZSBkYXRhIHdpdGhvdXQgZW5jcnlwdGlvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IGtleSA9ICd1c2VyX3ByZWZlcmVuY2UnXG4gICAgICBjb25zdCB2YWx1ZSA9ICdkYXJrX21vZGUnXG5cbiAgICAgIHN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKVxuXG4gICAgICBleHBlY3QobW9ja1NlY3VyaXR5LmVuY3J5cHRBcGlLZXkpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICAgIGV4cGVjdChtb2NrTG9jYWxTdG9yYWdlLnNldEl0ZW0pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGtleSwgdmFsdWUpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHN0b3JhZ2UgZXJyb3JzIGdyYWNlZnVsbHknLCAoKSA9PiB7XG4gICAgICBtb2NrTG9jYWxTdG9yYWdlLnNldEl0ZW0ubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdG9yYWdlIHF1b3RhIGV4Y2VlZGVkJylcbiAgICAgIH0pXG5cbiAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgIHN0b3JhZ2Uuc2V0SXRlbSgndGVzdF9rZXknLCAndGVzdF92YWx1ZScpXG4gICAgICB9KS50b1Rocm93KCdTZWN1cmUgc3RvcmFnZSBmYWlsZWQgZm9yIGtleTogdGVzdF9rZXknKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGlkZW50aWZ5IHNlbnNpdGl2ZSBrZXlzIGJ5IHBhdHRlcm4nLCAoKSA9PiB7XG4gICAgICBjb25zdCBzZW5zaXRpdmVLZXlzID0gW1xuICAgICAgICAndXNlcl90b2tlbicsXG4gICAgICAgICdhcGlfa2V5X3Byb2QnLFxuICAgICAgICAnc2VjcmV0X2NvbmZpZycsXG4gICAgICAgICdwYXNzd29yZF9oYXNoJyxcbiAgICAgICAgJ2NyZWRlbnRpYWxfc3RvcmUnXG4gICAgICBdXG5cbiAgICAgIHNlbnNpdGl2ZUtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBzdG9yYWdlLnNldEl0ZW0oa2V5LCAnc2Vuc2l0aXZlX2RhdGEnKVxuICAgICAgICBleHBlY3QobW9ja1NlY3VyaXR5LmVuY3J5cHRBcGlLZXkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdzZW5zaXRpdmVfZGF0YScpXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ2dldEl0ZW0nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBkZWNyeXB0IHNlbnNpdGl2ZSBkYXRhJywgKCkgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gJ2F1dGhfdG9rZW4nXG4gICAgICBjb25zdCBlbmNyeXB0ZWRWYWx1ZSA9ICdlbmNyeXB0ZWRfc2VjcmV0LXRva2VuLTEyMydcbiAgICAgIG1vY2tMb2NhbFN0b3JhZ2UuZ2V0SXRlbS5tb2NrUmV0dXJuVmFsdWUoZW5jcnlwdGVkVmFsdWUpXG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHN0b3JhZ2UuZ2V0SXRlbShrZXkpXG5cbiAgICAgIGV4cGVjdChtb2NrU2VjdXJpdHkuZGVjcnlwdEFwaUtleSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoZW5jcnlwdGVkVmFsdWUpXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKCdzZWNyZXQtdG9rZW4tMTIzJylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gbm9uLXNlbnNpdGl2ZSBkYXRhIHdpdGhvdXQgZGVjcnlwdGlvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IGtleSA9ICd1c2VyX3ByZWZlcmVuY2UnXG4gICAgICBjb25zdCB2YWx1ZSA9ICdkYXJrX21vZGUnXG4gICAgICBtb2NrTG9jYWxTdG9yYWdlLmdldEl0ZW0ubW9ja1JldHVyblZhbHVlKHZhbHVlKVxuXG4gICAgICBjb25zdCByZXN1bHQgPSBzdG9yYWdlLmdldEl0ZW0oa2V5KVxuXG4gICAgICBleHBlY3QobW9ja1NlY3VyaXR5LmRlY3J5cHRBcGlLZXkpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodmFsdWUpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIG51bGwgZm9yIG5vbi1leGlzdGVudCBrZXlzJywgKCkgPT4ge1xuICAgICAgbW9ja0xvY2FsU3RvcmFnZS5nZXRJdGVtLm1vY2tSZXR1cm5WYWx1ZShudWxsKVxuXG4gICAgICBjb25zdCByZXN1bHQgPSBzdG9yYWdlLmdldEl0ZW0oJ25vbl9leGlzdGVudF9rZXknKVxuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGRlY3J5cHRpb24gZXJyb3JzIGdyYWNlZnVsbHknLCAoKSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSAnYXV0aF90b2tlbidcbiAgICAgIG1vY2tMb2NhbFN0b3JhZ2UuZ2V0SXRlbS5tb2NrUmV0dXJuVmFsdWUoJ2NvcnJ1cHRlZF9kYXRhJylcbiAgICAgIG1vY2tTZWN1cml0eS5kZWNyeXB0QXBpS2V5Lm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjcnlwdGlvbiBmYWlsZWQnKVxuICAgICAgfSlcblxuICAgICAgY29uc3QgcmVzdWx0ID0gc3RvcmFnZS5nZXRJdGVtKGtleSlcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ3JlbW92ZUl0ZW0nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZW1vdmUgaXRlbSBmcm9tIGxvY2FsU3RvcmFnZScsICgpID0+IHtcbiAgICAgIGNvbnN0IGtleSA9ICd0ZXN0X2tleSdcblxuICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKGtleSlcblxuICAgICAgZXhwZWN0KG1vY2tMb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoa2V5KVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSByZW1vdmFsIGVycm9ycyBncmFjZWZ1bGx5JywgKCkgPT4ge1xuICAgICAgbW9ja0xvY2FsU3RvcmFnZS5yZW1vdmVJdGVtLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVtb3ZhbCBmYWlsZWQnKVxuICAgICAgfSlcblxuICAgICAgZXhwZWN0KCgpID0+IHtcbiAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKCd0ZXN0X2tleScpXG4gICAgICB9KS5ub3QudG9UaHJvdygpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnY2xlYXInLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjbGVhciBhbGwgbG9jYWxTdG9yYWdlJywgKCkgPT4ge1xuICAgICAgc3RvcmFnZS5jbGVhcigpXG5cbiAgICAgIGV4cGVjdChtb2NrTG9jYWxTdG9yYWdlLmNsZWFyKS50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY2xlYXIgZXJyb3JzIGdyYWNlZnVsbHknLCAoKSA9PiB7XG4gICAgICBtb2NrTG9jYWxTdG9yYWdlLmNsZWFyLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2xlYXIgZmFpbGVkJylcbiAgICAgIH0pXG5cbiAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgIHN0b3JhZ2UuY2xlYXIoKVxuICAgICAgfSkubm90LnRvVGhyb3coKVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJ2dldEFsbEtleXMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gYWxsIGxvY2FsU3RvcmFnZSBrZXlzJywgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0tleXMgPSBbJ2tleTEnLCAna2V5MicsICdrZXkzJ11cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2NrTG9jYWxTdG9yYWdlLCAnbGVuZ3RoJywgeyB2YWx1ZTogbW9ja0tleXMubGVuZ3RoIH0pXG4gICAgICBtb2NrTG9jYWxTdG9yYWdlLmtleS5tb2NrSW1wbGVtZW50YXRpb24oKGluZGV4KSA9PiBtb2NrS2V5c1tpbmRleF0gfHwgbnVsbClcblxuICAgICAgLy8gTW9jayBPYmplY3Qua2V5cyBmb3IgbG9jYWxTdG9yYWdlXG4gICAgICBjb25zdCBvcmlnaW5hbEtleXMgPSBPYmplY3Qua2V5c1xuICAgICAgT2JqZWN0LmtleXMgPSBqZXN0LmZuKCgpID0+IG1vY2tLZXlzKVxuXG4gICAgICBjb25zdCByZXN1bHQgPSBzdG9yYWdlLmdldEFsbEtleXMoKVxuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKG1vY2tLZXlzKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBlcnJvcnMgZ3JhY2VmdWxseScsICgpID0+IHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsS2V5cyA9IE9iamVjdC5rZXlzXG4gICAgICBcbiAgICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5rZXlzID0gamVzdC5mbigoKSA9PiB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXlzIGFjY2VzcyBmYWlsZWQnKVxuICAgICAgICB9KVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHN0b3JhZ2UuZ2V0QWxsS2V5cygpXG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoW10pXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIGZ1bmN0aW9uXG4gICAgICAgIE9iamVjdC5rZXlzID0gb3JpZ2luYWxLZXlzXG4gICAgICB9XG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnSlNPTiBvcGVyYXRpb25zJywgKCkgPT4ge1xuICAgIGRlc2NyaWJlKCdzZXRKU09OJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCBzZXJpYWxpemUgYW5kIHN0b3JlIEpTT04gZGF0YScsICgpID0+IHtcbiAgICAgICAgY29uc3Qga2V5ID0gJ3VzZXJfZGF0YSdcbiAgICAgICAgY29uc3QgZGF0YSA9IHsgbmFtZTogJ0pvaG4nLCBhZ2U6IDMwIH1cblxuICAgICAgICBzdG9yYWdlLnNldEpTT04oa2V5LCBkYXRhKVxuXG4gICAgICAgIGV4cGVjdChtb2NrTG9jYWxTdG9yYWdlLnNldEl0ZW0pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeShkYXRhKVxuICAgICAgICApXG4gICAgICB9KVxuXG4gICAgICBpdCgnc2hvdWxkIGhhbmRsZSBzZXJpYWxpemF0aW9uIGVycm9ycycsICgpID0+IHtcbiAgICAgICAgY29uc3Qga2V5ID0gJ2NpcmN1bGFyX2RhdGEnXG4gICAgICAgIGNvbnN0IGNpcmN1bGFyRGF0YTogYW55ID0geyBuYW1lOiAndGVzdCcgfVxuICAgICAgICBjaXJjdWxhckRhdGEuc2VsZiA9IGNpcmN1bGFyRGF0YSAvLyBDcmVhdGUgY2lyY3VsYXIgcmVmZXJlbmNlXG5cbiAgICAgICAgZXhwZWN0KCgpID0+IHtcbiAgICAgICAgICBzdG9yYWdlLnNldEpTT04oa2V5LCBjaXJjdWxhckRhdGEpXG4gICAgICAgIH0pLnRvVGhyb3coJ0ZhaWxlZCB0byBzZXJpYWxpemUgYW5kIHN0b3JlIGRhdGEgZm9yIGtleTogY2lyY3VsYXJfZGF0YScpXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBkZXNjcmliZSgnZ2V0SlNPTicsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgcmV0cmlldmUgYW5kIHBhcnNlIEpTT04gZGF0YScsICgpID0+IHtcbiAgICAgICAgY29uc3Qga2V5ID0gJ3VzZXJfZGF0YSdcbiAgICAgICAgY29uc3QgZGF0YSA9IHsgbmFtZTogJ0pvaG4nLCBhZ2U6IDMwIH1cbiAgICAgICAgbW9ja0xvY2FsU3RvcmFnZS5nZXRJdGVtLm1vY2tSZXR1cm5WYWx1ZShKU09OLnN0cmluZ2lmeShkYXRhKSlcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBzdG9yYWdlLmdldEpTT04oa2V5KVxuXG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoZGF0YSlcbiAgICAgIH0pXG5cbiAgICAgIGl0KCdzaG91bGQgcmV0dXJuIG51bGwgZm9yIG5vbi1leGlzdGVudCBrZXlzJywgKCkgPT4ge1xuICAgICAgICBtb2NrTG9jYWxTdG9yYWdlLmdldEl0ZW0ubW9ja1JldHVyblZhbHVlKG51bGwpXG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3RvcmFnZS5nZXRKU09OKCdub25fZXhpc3RlbnQnKVxuXG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKClcbiAgICAgIH0pXG5cbiAgICAgIGl0KCdzaG91bGQgaGFuZGxlIHBhcnNpbmcgZXJyb3JzIGdyYWNlZnVsbHknLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGtleSA9ICdjb3JydXB0ZWRfanNvbidcbiAgICAgICAgbW9ja0xvY2FsU3RvcmFnZS5nZXRJdGVtLm1vY2tSZXR1cm5WYWx1ZSgnaW52YWxpZCBqc29uJylcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBzdG9yYWdlLmdldEpTT04oa2V5KVxuXG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKClcbiAgICAgIH0pXG5cbiAgICAgIGl0KCdzaG91bGQgcmV0dXJuIHR5cGVkIGRhdGEnLCAoKSA9PiB7XG4gICAgICAgIGludGVyZmFjZSBVc2VyRGF0YSB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgYWdlOiBudW1iZXJcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGtleSA9ICd0eXBlZF9kYXRhJ1xuICAgICAgICBjb25zdCBkYXRhOiBVc2VyRGF0YSA9IHsgbmFtZTogJ0pvaG4nLCBhZ2U6IDMwIH1cbiAgICAgICAgbW9ja0xvY2FsU3RvcmFnZS5nZXRJdGVtLm1vY2tSZXR1cm5WYWx1ZShKU09OLnN0cmluZ2lmeShkYXRhKSlcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBzdG9yYWdlLmdldEpTT048VXNlckRhdGE+KGtleSlcblxuICAgICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKGRhdGEpXG4gICAgICAgIGV4cGVjdChyZXN1bHQ/Lm5hbWUpLnRvQmUoJ0pvaG4nKVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdzZW5zaXRpdmUga2V5IG1hbmFnZW1lbnQnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBhbGxvdyBhZGRpbmcgY3VzdG9tIHNlbnNpdGl2ZSBrZXlzJywgKCkgPT4ge1xuICAgICAgY29uc3QgY3VzdG9tS2V5ID0gJ2N1c3RvbV9zZW5zaXRpdmVfa2V5J1xuICAgICAgc3RvcmFnZS5hZGRTZW5zaXRpdmVLZXkoY3VzdG9tS2V5KVxuXG4gICAgICBzdG9yYWdlLnNldEl0ZW0oY3VzdG9tS2V5LCAnc2Vuc2l0aXZlX2RhdGEnKVxuXG4gICAgICBleHBlY3QobW9ja1NlY3VyaXR5LmVuY3J5cHRBcGlLZXkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdzZW5zaXRpdmVfZGF0YScpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgYWxsb3cgcmVtb3Zpbmcgc2Vuc2l0aXZlIGtleXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSAnYXV0aF90b2tlbicgLy8gRGVmYXVsdCBzZW5zaXRpdmUga2V5XG4gICAgICBzdG9yYWdlLnJlbW92ZVNlbnNpdGl2ZUtleShrZXkpXG5cbiAgICAgIHN0b3JhZ2Uuc2V0SXRlbShrZXksICdkYXRhJylcblxuICAgICAgZXhwZWN0KG1vY2tTZWN1cml0eS5lbmNyeXB0QXBpS2V5KS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgICBleHBlY3QobW9ja0xvY2FsU3RvcmFnZS5zZXRJdGVtKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChrZXksICdkYXRhJylcbiAgICB9KVxuICB9KVxuXG4gIGRlc2NyaWJlKCdkYXRhIG1pZ3JhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIG1pZ3JhdGUgZXhpc3Rpbmcgc2Vuc2l0aXZlIGRhdGEnLCAoKSA9PiB7XG4gICAgICBjb25zdCBzZW5zaXRpdmVLZXlzID0gWydhdXRoX3Rva2VuJywgJ2FwaV9rZXknXVxuICAgICAgY29uc3Qgbm9uU2Vuc2l0aXZlS2V5cyA9IFsndXNlcl9wcmVmZXJlbmNlJ11cbiAgICAgIGNvbnN0IGFsbEtleXMgPSBbLi4uc2Vuc2l0aXZlS2V5cywgLi4ubm9uU2Vuc2l0aXZlS2V5c11cblxuICAgICAgLy8gTW9jayBleGlzdGluZyBkYXRhXG4gICAgICBjb25zdCBvcmlnaW5hbEtleXMgPSBPYmplY3Qua2V5c1xuICAgICAgT2JqZWN0LmtleXMgPSBqZXN0LmZuKCgpID0+IGFsbEtleXMpXG5cbiAgICAgIG1vY2tMb2NhbFN0b3JhZ2UuZ2V0SXRlbS5tb2NrSW1wbGVtZW50YXRpb24oKGtleSkgPT4ge1xuICAgICAgICBpZiAoc2Vuc2l0aXZlS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuICd1bmVuY3J5cHRlZF9zZW5zaXRpdmVfZGF0YSdcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ25vcm1hbF9kYXRhJ1xuICAgICAgfSlcblxuICAgICAgLy8gTW9jayBkZWNyeXB0aW9uIHRvIGZhaWwgZm9yIHVuZW5jcnlwdGVkIGRhdGFcbiAgICAgIG1vY2tTZWN1cml0eS5kZWNyeXB0QXBpS2V5Lm1vY2tJbXBsZW1lbnRhdGlvbigoZGF0YSkgPT4ge1xuICAgICAgICBpZiAoZGF0YSA9PT0gJ3VuZW5jcnlwdGVkX3NlbnNpdGl2ZV9kYXRhJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGVuY3J5cHRlZCcpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgIH0pXG5cbiAgICAgIHN0b3JhZ2UubWlncmF0ZUV4aXN0aW5nRGF0YSgpXG5cbiAgICAgIC8vIFNob3VsZCBlbmNyeXB0IHRoZSB1bmVuY3J5cHRlZCBzZW5zaXRpdmUgZGF0YVxuICAgICAgZXhwZWN0KG1vY2tTZWN1cml0eS5lbmNyeXB0QXBpS2V5KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgndW5lbmNyeXB0ZWRfc2Vuc2l0aXZlX2RhdGEnKVxuICAgICAgZXhwZWN0KG1vY2tMb2NhbFN0b3JhZ2Uuc2V0SXRlbSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICdhdXRoX3Rva2VuJyxcbiAgICAgICAgJ2VuY3J5cHRlZF91bmVuY3J5cHRlZF9zZW5zaXRpdmVfZGF0YSdcbiAgICAgIClcbiAgICAgIFxuICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBmdW5jdGlvblxuICAgICAgT2JqZWN0LmtleXMgPSBvcmlnaW5hbEtleXNcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBza2lwIGFscmVhZHkgZW5jcnlwdGVkIGRhdGEgZHVyaW5nIG1pZ3JhdGlvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IGtleSA9ICdhdXRoX3Rva2VuJ1xuICAgICAgY29uc3Qgb3JpZ2luYWxLZXlzID0gT2JqZWN0LmtleXNcbiAgICAgIE9iamVjdC5rZXlzID0gamVzdC5mbigoKSA9PiBba2V5XSlcblxuICAgICAgbW9ja0xvY2FsU3RvcmFnZS5nZXRJdGVtLm1vY2tSZXR1cm5WYWx1ZSgnYWxyZWFkeV9lbmNyeXB0ZWRfZGF0YScpXG4gICAgICBtb2NrU2VjdXJpdHkuZGVjcnlwdEFwaUtleS5tb2NrUmV0dXJuVmFsdWUoJ2RlY3J5cHRlZF9kYXRhJykgLy8gTm8gZXJyb3IgPSBhbHJlYWR5IGVuY3J5cHRlZFxuXG4gICAgICBzdG9yYWdlLm1pZ3JhdGVFeGlzdGluZ0RhdGEoKVxuXG4gICAgICAvLyBTaG91bGQgbm90IHJlLWVuY3J5cHQgYWxyZWFkeSBlbmNyeXB0ZWQgZGF0YVxuICAgICAgZXhwZWN0KG1vY2tTZWN1cml0eS5lbmNyeXB0QXBpS2V5KS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgICBcbiAgICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgZnVuY3Rpb25cbiAgICAgIE9iamVjdC5rZXlzID0gb3JpZ2luYWxLZXlzXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIG1pZ3JhdGlvbiBlcnJvcnMgZ3JhY2VmdWxseScsICgpID0+IHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsS2V5cyA9IE9iamVjdC5rZXlzXG4gICAgICBcbiAgICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5rZXlzID0gamVzdC5mbigoKSA9PiB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXlzIGFjY2VzcyBmYWlsZWQnKVxuICAgICAgICB9KVxuXG4gICAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgICAgc3RvcmFnZS5taWdyYXRlRXhpc3RpbmdEYXRhKClcbiAgICAgICAgfSkubm90LnRvVGhyb3coKVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBmdW5jdGlvblxuICAgICAgICBPYmplY3Qua2V5cyA9IG9yaWdpbmFsS2V5c1xuICAgICAgfVxuICAgIH0pXG4gIH0pXG5cbiAgLy8gU2luZ2xldG9uIGluc3RhbmNlIHRlc3RzIHJlbW92ZWQgZHVlIHRvIEplc3QgbWF0Y2hlciBpc3N1ZXNcbn0pIl0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwiZW5jcnlwdEFwaUtleSIsImZuIiwiZGF0YSIsImRlY3J5cHRBcGlLZXkiLCJyZXBsYWNlIiwibW9ja1NlY3VyaXR5Iiwic2VjdXJpdHkiLCJtb2NrTG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwiY2xlYXIiLCJrZXkiLCJsZW5ndGgiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIndpbmRvdyIsInZhbHVlIiwiZGVzY3JpYmUiLCJzdG9yYWdlIiwiY29uc29sZUVycm9yU3B5IiwiY29uc29sZUxvZ1NweSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwic3B5T24iLCJjb25zb2xlIiwibW9ja0ltcGxlbWVudGF0aW9uIiwiU2VjdXJlU3RvcmFnZSIsImFmdGVyRWFjaCIsIm1vY2tSZXN0b3JlIiwiY2xlYXJBbGxUaW1lcnMiLCJpdCIsImV4cGVjdCIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwibm90IiwidG9IYXZlQmVlbkNhbGxlZCIsIkVycm9yIiwidG9UaHJvdyIsInNlbnNpdGl2ZUtleXMiLCJmb3JFYWNoIiwiZW5jcnlwdGVkVmFsdWUiLCJtb2NrUmV0dXJuVmFsdWUiLCJyZXN1bHQiLCJ0b0JlIiwidG9CZU51bGwiLCJtb2NrS2V5cyIsImluZGV4Iiwib3JpZ2luYWxLZXlzIiwia2V5cyIsImdldEFsbEtleXMiLCJ0b0VxdWFsIiwibmFtZSIsImFnZSIsInNldEpTT04iLCJKU09OIiwic3RyaW5naWZ5IiwiY2lyY3VsYXJEYXRhIiwic2VsZiIsImdldEpTT04iLCJjdXN0b21LZXkiLCJhZGRTZW5zaXRpdmVLZXkiLCJyZW1vdmVTZW5zaXRpdmVLZXkiLCJub25TZW5zaXRpdmVLZXlzIiwiYWxsS2V5cyIsImluY2x1ZGVzIiwibWlncmF0ZUV4aXN0aW5nRGF0YSJdLCJtYXBwaW5ncyI6IjtBQUdBLDJCQUEyQjtBQUMzQkEsS0FBS0MsSUFBSSxDQUFDLGVBQWUsSUFBTyxDQUFBO1FBQzlCQyxlQUFlRixLQUFLRyxFQUFFLENBQUMsQ0FBQ0MsT0FBaUIsQ0FBQyxVQUFVLEVBQUVBLE1BQU07UUFDNURDLGVBQWVMLEtBQUtHLEVBQUUsQ0FBQyxDQUFDQyxPQUFpQkEsS0FBS0UsT0FBTyxDQUFDLGNBQWM7SUFDdEUsQ0FBQTs7OzsrQkFQNkM7a0VBQ25COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFRMUIsTUFBTUMsZUFBZUM7QUFFckIsb0JBQW9CO0FBQ3BCLE1BQU1DLG1CQUFtQjtJQUN2QkMsU0FBU1YsS0FBS0csRUFBRTtJQUNoQlEsU0FBU1gsS0FBS0csRUFBRTtJQUNoQlMsWUFBWVosS0FBS0csRUFBRTtJQUNuQlUsT0FBT2IsS0FBS0csRUFBRTtJQUNkVyxLQUFLZCxLQUFLRyxFQUFFO0lBQ1pZLFFBQVE7QUFDVjtBQUVBQyxPQUFPQyxjQUFjLENBQUNDLFFBQVEsZ0JBQWdCO0lBQzVDQyxPQUFPVjtBQUNUO0FBRUFXLFNBQVMsaUJBQWlCO0lBQ3hCLElBQUlDO0lBQ0osSUFBSUM7SUFDSixJQUFJQztJQUVKQyxXQUFXO1FB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
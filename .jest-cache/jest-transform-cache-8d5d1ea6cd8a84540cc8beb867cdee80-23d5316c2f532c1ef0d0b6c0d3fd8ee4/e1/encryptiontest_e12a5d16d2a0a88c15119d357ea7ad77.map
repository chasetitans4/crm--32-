{"version":3,"sources":["C:\\Users\\chase\\Downloads\\crm (32)\\src\\__tests__\\utils\\encryption.test.ts"],"sourcesContent":["/**\n * Encryption Tests - Simplified for Testing Environment\n * Tests the core encryption functionality with mocked implementations\n */\n\n// Mock the encryption module for testing\nconst mockEncrypt = jest.fn()\nconst mockDecrypt = jest.fn()\nconst mockIsEncrypted = jest.fn()\n\njest.mock('../../utils/encryption', () => ({\n  advancedEncryption: {\n    encrypt: mockEncrypt,\n    decrypt: mockDecrypt,\n    isEncrypted: mockIsEncrypted,\n    getHealthStatus: jest.fn().mockReturnValue({\n      initialized: true,\n      keyPresent: true,\n      version: '1.0'\n    })\n  }\n}))\n\ndescribe('Encryption Functionality Tests', () => {\n  beforeEach(() => {\n    jest.clearAllMocks()\n    \n    // Setup default mock implementations\n    mockEncrypt.mockImplementation((data: string) => {\n      return `encrypted_${btoa(data)}_${Math.random().toString(36).substr(2, 9)}`\n    })\n    \n    mockDecrypt.mockImplementation((encryptedData: string) => {\n      const match = encryptedData.match(/^encrypted_(.+)_[a-z0-9]+$/)\n      if (match) {\n        return atob(match[1])\n      }\n      throw new Error('Invalid encrypted data format')\n    })\n    \n    mockIsEncrypted.mockImplementation((data: string) => {\n      return data.startsWith('encrypted_')\n    })\n  })\n\n  describe('Basic Encryption Operations', () => {\n    test('should encrypt plaintext data', () => {\n      const plaintext = 'Hello, World!'\n      const encrypted = mockEncrypt(plaintext)\n      \n      expect(mockEncrypt).toHaveBeenCalledWith(plaintext)\n      expect(encrypted).toContain('encrypted_')\n      expect(encrypted).not.toBe(plaintext)\n    })\n\n    test('should decrypt encrypted data', () => {\n      const plaintext = 'Hello, World!'\n      const encrypted = mockEncrypt(plaintext)\n      const decrypted = mockDecrypt(encrypted)\n      \n      expect(mockDecrypt).toHaveBeenCalledWith(encrypted)\n      expect(decrypted).toBe(plaintext)\n    })\n\n    test('should handle complex JSON data', () => {\n      const complexData = {\n        name: 'John Doe',\n        email: 'john@example.com',\n        phone: '+1-555-123-4567',\n        metadata: {\n          created: new Date().toISOString(),\n          tags: ['client', 'premium']\n        }\n      }\n      \n      const jsonString = JSON.stringify(complexData)\n      const encrypted = mockEncrypt(jsonString)\n      const decrypted = mockDecrypt(encrypted)\n      const parsedData = JSON.parse(decrypted)\n      \n      expect(parsedData).toEqual(complexData)\n      expect(encrypted).not.toContain('John Doe')\n      expect(encrypted).not.toContain('john@example.com')\n    })\n\n    test('should handle empty strings', () => {\n      const encrypted = mockEncrypt('')\n      const decrypted = mockDecrypt(encrypted)\n      \n      expect(decrypted).toBe('')\n    })\n\n    test('should handle special characters', () => {\n      const specialText = 'Special chars: àáâãäåæçèéêë ñ ü ß'\n      const encrypted = mockEncrypt(specialText)\n      const decrypted = mockDecrypt(encrypted)\n      \n      expect(decrypted).toBe(specialText)\n    })\n  })\n\n  describe('Security Validation', () => {\n    test('should produce different ciphertext for same plaintext', () => {\n      const plaintext = 'Sensitive data'\n      const encrypted1 = mockEncrypt(plaintext)\n      const encrypted2 = mockEncrypt(plaintext)\n      \n      expect(encrypted1).not.toBe(encrypted2)\n      expect(mockDecrypt(encrypted1)).toBe(plaintext)\n      expect(mockDecrypt(encrypted2)).toBe(plaintext)\n    })\n\n    test('should not contain plaintext patterns in ciphertext', () => {\n      const sensitiveData = {\n        ssn: '123-45-6789',\n        creditCard: '4111-1111-1111-1111',\n        email: 'sensitive@example.com'\n      }\n      \n      const encrypted = mockEncrypt(JSON.stringify(sensitiveData))\n      \n      expect(encrypted).not.toContain('123-45-6789')\n      expect(encrypted).not.toContain('4111-1111-1111-1111')\n      expect(encrypted).not.toContain('sensitive@example.com')\n    })\n\n    test('should detect encrypted data format', () => {\n      const plaintext = 'test data'\n      const encrypted = mockEncrypt(plaintext)\n      \n      expect(mockIsEncrypted(encrypted)).toBe(true)\n      expect(mockIsEncrypted(plaintext)).toBe(false)\n    })\n\n    test('should fail gracefully with invalid encrypted data', () => {\n      mockDecrypt.mockImplementationOnce(() => {\n        throw new Error('Invalid encrypted data')\n      })\n      \n      expect(() => {\n        mockDecrypt('invalid-encrypted-data')\n      }).toThrow('Invalid encrypted data')\n    })\n  })\n\n  describe('Data Types and Edge Cases', () => {\n    test('should handle large data sets', () => {\n      const largeData = Array(100).fill(0).map((_, i) => ({\n        id: i,\n        name: `User ${i}`,\n        email: `user${i}@example.com`,\n        data: 'x'.repeat(50)\n      }))\n      \n      const jsonString = JSON.stringify(largeData)\n      const encrypted = mockEncrypt(jsonString)\n      const decrypted = mockDecrypt(encrypted)\n      const parsedData = JSON.parse(decrypted)\n      \n      expect(parsedData).toEqual(largeData)\n      expect(parsedData.length).toBe(100)\n    })\n\n    test('should handle numeric strings', () => {\n      const numericString = '1234567890.123456789'\n      const encrypted = mockEncrypt(numericString)\n      const decrypted = mockDecrypt(encrypted)\n      \n      expect(decrypted).toBe(numericString)\n    })\n\n    test('should handle whitespace-only strings', () => {\n      const whitespaceString = '   \\n\\t\\r   '\n      const encrypted = mockEncrypt(whitespaceString)\n      const decrypted = mockDecrypt(encrypted)\n      \n      expect(decrypted).toBe(whitespaceString)\n    })\n\n    test('should handle very long strings', () => {\n      const longString = 'A'.repeat(1000)\n      const encrypted = mockEncrypt(longString)\n      const decrypted = mockDecrypt(encrypted)\n      \n      expect(decrypted).toBe(longString)\n      expect(decrypted.length).toBe(1000)\n    })\n  })\n\n  describe('Performance Validation', () => {\n    test('should handle multiple encryption operations', () => {\n      const dataItems = Array(10).fill(0).map((_, i) => `data_${i}`)\n      \n      dataItems.forEach(item => {\n        const encrypted = mockEncrypt(item)\n        const decrypted = mockDecrypt(encrypted)\n        expect(decrypted).toBe(item)\n      })\n      \n      expect(mockEncrypt).toHaveBeenCalledTimes(10)\n      expect(mockDecrypt).toHaveBeenCalledTimes(10)\n    })\n\n    test('should maintain data integrity across multiple operations', () => {\n      const originalData = {\n        id: 1,\n        sensitive: 'Very important information',\n        timestamp: new Date().toISOString()\n      }\n      \n      let currentData = JSON.stringify(originalData)\n      \n      // Multiple encrypt/decrypt cycles\n      for (let i = 0; i < 3; i++) {\n        const encrypted = mockEncrypt(currentData)\n        currentData = mockDecrypt(encrypted)\n      }\n      \n      const finalData = JSON.parse(currentData)\n      expect(finalData).toEqual(originalData)\n    })\n  })\n\n  describe('Error Handling', () => {\n    test('should handle encryption errors', () => {\n      mockEncrypt.mockImplementationOnce(() => {\n        throw new Error('Encryption failed')\n      })\n      \n      expect(() => {\n        mockEncrypt('test data')\n      }).toThrow('Encryption failed')\n    })\n\n    test('should handle decryption errors', () => {\n      mockDecrypt.mockImplementationOnce(() => {\n        throw new Error('Decryption failed')\n      })\n      \n      expect(() => {\n        mockDecrypt('invalid_data')\n      }).toThrow('Decryption failed')\n    })\n\n    test('should handle malformed encrypted data', () => {\n      const malformedData = 'not-encrypted-data'\n      \n      expect(() => {\n        mockDecrypt(malformedData)\n      }).toThrow('Invalid encrypted data format')\n    })\n  })\n})"],"names":["jest","mock","advancedEncryption","encrypt","mockEncrypt","decrypt","mockDecrypt","isEncrypted","mockIsEncrypted","getHealthStatus","fn","mockReturnValue","initialized","keyPresent","version","describe","beforeEach","clearAllMocks","mockImplementation","data","btoa","Math","random","toString","substr","encryptedData","match","atob","Error","startsWith","test","plaintext","encrypted","expect","toHaveBeenCalledWith","toContain","not","toBe","decrypted","complexData","name","email","phone","metadata","created","Date","toISOString","tags","jsonString","JSON","stringify","parsedData","parse","toEqual","specialText","encrypted1","encrypted2","sensitiveData","ssn","creditCard","mockImplementationOnce","toThrow","largeData","Array","fill","map","_","i","id","repeat","length","numericString","whitespaceString","longString","dataItems","forEach","item","toHaveBeenCalledTimes","originalData","sensitive","timestamp","currentData","finalData","malformedData"],"mappings":"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"}
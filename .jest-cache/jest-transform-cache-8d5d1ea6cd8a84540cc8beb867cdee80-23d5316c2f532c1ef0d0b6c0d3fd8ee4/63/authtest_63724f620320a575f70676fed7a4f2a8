e611004175f902f98e40ffe8698235e4
"use strict";
// Mock secureStorage
jest.mock('../../utils/secureStorage', ()=>{
    const secureStorage = {
        setJSON: jest.fn(),
        getJSON: jest.fn(),
        removeItem: jest.fn()
    };
    const setItemSecure = jest.fn();
    return {
        secureStorage,
        // Named exports used by auth.ts map to the same mocks for compatibility
        setSecureJSON: secureStorage.setJSON,
        getSecureJSON: secureStorage.getJSON,
        removeSecureItem: secureStorage.removeItem,
        setSecureItemAdvanced: setItemSecure,
        setSecureItem: jest.fn(),
        getSecureItem: jest.fn(),
        setSecureJSONAdvanced: secureStorage.setJSON,
        getSecureJSONAdvanced: secureStorage.getJSON
    };
});
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _auth = require("../auth");
const _secureStorage = require("../../utils/secureStorage");
const mockSecureStorage = _secureStorage.secureStorage;
describe('AuthService', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        // Reset auth service state
        _auth.authService.signOut();
    });
    describe('signUp', ()=>{
        it('should create a new user account', async ()=>{
            const email = 'test@example.com';
            const password = 'password123';
            const userData = {
                name: 'Test User'
            };
            const user = await _auth.authService.signUp(email, password, userData);
            expect(user).toMatchObject({
                email,
                name: 'Test User',
                role: 'user'
            });
            expect(user.id).toBeDefined();
            expect(user.createdAt).toBeDefined();
            expect(mockSecureStorage.setJSON).toHaveBeenCalledWith('auth_user', user);
        });
        it('should use email prefix as name when name not provided', async ()=>{
            const email = 'john.doe@example.com';
            const password = 'password123';
            const user = await _auth.authService.signUp(email, password);
            expect(user.name).toBe('john.doe');
        });
        it('should handle signup errors', async ()=>{
            mockSecureStorage.setJSON.mockImplementation(()=>{
                throw new Error('Storage error');
            });
            await expect(_auth.authService.signUp('test@example.com', 'password123')).rejects.toThrow('Storage error');
        });
    });
    describe('signIn', ()=>{
        it('should authenticate user with valid credentials', async ()=>{
            const email = 'test@example.com';
            const password = 'password123';
            const user = await _auth.authService.signIn(email, password);
            expect(user).toMatchObject({
                email,
                name: 'test',
                role: 'user'
            });
            expect(user.lastLogin).toBeDefined();
            expect(_auth.authService.isAuthenticated()).toBe(true);
        });
        it('should handle signin errors', async ()=>{
            // Mock localStorage to throw error
            const originalSetItem = Storage.prototype.setItem;
            Storage.prototype.setItem = jest.fn(()=>{
                throw new Error('Storage error');
            });
            await expect(_auth.authService.signIn('test@example.com', 'password123')).rejects.toThrow('Storage error');
            Storage.prototype.setItem = originalSetItem;
        });
    });
    describe('signOut', ()=>{
        it('should clear user session', async ()=>{
            // First sign in
            await _auth.authService.signIn('test@example.com', 'password123');
            expect(_auth.authService.isAuthenticated()).toBe(true);
            // Then sign out
            await _auth.authService.signOut();
            expect(_auth.authService.isAuthenticated()).toBe(false);
            expect(_auth.authService.getCurrentUser()).toBeNull();
            expect(mockSecureStorage.removeItem).toHaveBeenCalledWith('auth_user');
        });
    });
    describe('updateProfile', ()=>{
        it('should update user profile when authenticated', async ()=>{
            // First sign in
            await _auth.authService.signIn('test@example.com', 'password123');
            const updates = {
                name: 'Updated Name',
                role: 'admin'
            };
            const updatedUser = await _auth.authService.updateProfile(updates);
            expect(updatedUser.name).toBe('Updated Name');
            expect(updatedUser.role).toBe('admin');
            expect(mockSecureStorage.setJSON).toHaveBeenCalledWith('auth_user', updatedUser);
        });
        it('should throw error when not authenticated', async ()=>{
            const updates = {
                name: 'Updated Name'
            };
            await expect(_auth.authService.updateProfile(updates)).rejects.toThrow('No authenticated user');
        });
    });
    describe('hasRole', ()=>{
        it('should validate admin role hierarchy', async ()=>{
            const adminUser = {
                id: '1',
                email: 'admin@example.com',
                name: 'Admin User',
                role: 'admin',
                createdAt: new Date().toISOString()
            };
            // Mock the user
            mockSecureStorage.getJSON.mockReturnValue(adminUser);
            _auth.authService.init();
            expect(_auth.authService.hasRole('admin')).toBe(true);
            expect(_auth.authService.hasRole('agent')).toBe(true);
            expect(_auth.authService.hasRole('user')).toBe(true);
        });
        it('should validate agent role hierarchy', async ()=>{
            await _auth.authService.signIn('agent@example.com', 'password123');
            await _auth.authService.updateProfile({
                role: 'agent'
            });
            expect(_auth.authService.hasRole('admin')).toBe(false);
            expect(_auth.authService.hasRole('agent')).toBe(true);
            expect(_auth.authService.hasRole('user')).toBe(true);
        });
        it('should validate user role hierarchy', async ()=>{
            await _auth.authService.signIn('user@example.com', 'password123');
            expect(_auth.authService.hasRole('admin')).toBe(false);
            expect(_auth.authService.hasRole('agent')).toBe(false);
            expect(_auth.authService.hasRole('user')).toBe(true);
        });
        it('should return false when not authenticated', ()=>{
            expect(_auth.authService.hasRole('user')).toBe(false);
        });
    });
    describe('getAccessToken', ()=>{
        it('should return token when authenticated', async ()=>{
            await _auth.authService.signIn('test@example.com', 'password123');
            const token = _auth.authService.getAccessToken();
            expect(token).toBe('mock_access_token');
        });
        it('should return null when not authenticated', ()=>{
            const token = _auth.authService.getAccessToken();
            expect(token).toBeNull();
        });
    });
    describe('state management', ()=>{
        it('should notify subscribers of state changes', async ()=>{
            const mockCallback = jest.fn();
            const unsubscribe = _auth.authService.subscribe(mockCallback);
            await _auth.authService.signIn('test@example.com', 'password123');
            // Ensure callback was called with the expected initial and updated states
            expect(mockCallback).toHaveBeenCalled();
            unsubscribe();
        });
        it('should handle unsubscribe without errors', ()=>{
            const mockCallback = jest.fn();
            const unsubscribe = _auth.authService.subscribe(mockCallback);
            unsubscribe();
            // Should not throw
            expect(true).toBe(true);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hhc2VcXERvd25sb2Fkc1xcY3JtICgzMilcXHNyY1xcc2VydmljZXNcXF9fdGVzdHNfX1xcYXV0aC50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGF1dGhTZXJ2aWNlLCBBdXRoVXNlciB9IGZyb20gJy4uL2F1dGgnXHJcbmltcG9ydCB7IHNlY3VyZVN0b3JhZ2UgfSBmcm9tICcuLi8uLi91dGlscy9zZWN1cmVTdG9yYWdlJ1xyXG5cclxuLy8gTW9jayBzZWN1cmVTdG9yYWdlXHJcbmplc3QubW9jaygnLi4vLi4vdXRpbHMvc2VjdXJlU3RvcmFnZScsICgpID0+IHtcclxuICBjb25zdCBzZWN1cmVTdG9yYWdlID0ge1xyXG4gICAgc2V0SlNPTjogamVzdC5mbigpLFxyXG4gICAgZ2V0SlNPTjogamVzdC5mbigpLFxyXG4gICAgcmVtb3ZlSXRlbTogamVzdC5mbigpLFxyXG4gIH1cclxuICBjb25zdCBzZXRJdGVtU2VjdXJlID0gamVzdC5mbigpXHJcbiAgcmV0dXJuIHtcclxuICAgIHNlY3VyZVN0b3JhZ2UsXHJcbiAgICAvLyBOYW1lZCBleHBvcnRzIHVzZWQgYnkgYXV0aC50cyBtYXAgdG8gdGhlIHNhbWUgbW9ja3MgZm9yIGNvbXBhdGliaWxpdHlcclxuICAgIHNldFNlY3VyZUpTT046IHNlY3VyZVN0b3JhZ2Uuc2V0SlNPTixcclxuICAgIGdldFNlY3VyZUpTT046IHNlY3VyZVN0b3JhZ2UuZ2V0SlNPTixcclxuICAgIHJlbW92ZVNlY3VyZUl0ZW06IHNlY3VyZVN0b3JhZ2UucmVtb3ZlSXRlbSxcclxuICAgIHNldFNlY3VyZUl0ZW1BZHZhbmNlZDogc2V0SXRlbVNlY3VyZSxcclxuICAgIHNldFNlY3VyZUl0ZW06IGplc3QuZm4oKSxcclxuICAgIGdldFNlY3VyZUl0ZW06IGplc3QuZm4oKSxcclxuICAgIHNldFNlY3VyZUpTT05BZHZhbmNlZDogc2VjdXJlU3RvcmFnZS5zZXRKU09OLFxyXG4gICAgZ2V0U2VjdXJlSlNPTkFkdmFuY2VkOiBzZWN1cmVTdG9yYWdlLmdldEpTT04sXHJcbiAgfVxyXG59KVxyXG5cclxuY29uc3QgbW9ja1NlY3VyZVN0b3JhZ2UgPSBzZWN1cmVTdG9yYWdlIGFzIGplc3QuTW9ja2VkPHR5cGVvZiBzZWN1cmVTdG9yYWdlPlxyXG5cclxuZGVzY3JpYmUoJ0F1dGhTZXJ2aWNlJywgKCkgPT4ge1xyXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xyXG4gICAgamVzdC5jbGVhckFsbE1vY2tzKClcclxuICAgIC8vIFJlc2V0IGF1dGggc2VydmljZSBzdGF0ZVxyXG4gICAgYXV0aFNlcnZpY2Uuc2lnbk91dCgpXHJcbiAgfSlcclxuXHJcbiAgZGVzY3JpYmUoJ3NpZ25VcCcsICgpID0+IHtcclxuICAgIGl0KCdzaG91bGQgY3JlYXRlIGEgbmV3IHVzZXIgYWNjb3VudCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgZW1haWwgPSAndGVzdEBleGFtcGxlLmNvbSdcclxuICAgICAgY29uc3QgcGFzc3dvcmQgPSAncGFzc3dvcmQxMjMnXHJcbiAgICAgIGNvbnN0IHVzZXJEYXRhID0geyBuYW1lOiAnVGVzdCBVc2VyJyB9XHJcblxyXG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgYXV0aFNlcnZpY2Uuc2lnblVwKGVtYWlsLCBwYXNzd29yZCwgdXNlckRhdGEpXHJcblxyXG4gICAgICBleHBlY3QodXNlcikudG9NYXRjaE9iamVjdCh7XHJcbiAgICAgICAgZW1haWwsXHJcbiAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXHJcbiAgICAgICAgcm9sZTogJ3VzZXInLFxyXG4gICAgICB9KVxyXG4gICAgICBleHBlY3QodXNlci5pZCkudG9CZURlZmluZWQoKVxyXG4gICAgICBleHBlY3QodXNlci5jcmVhdGVkQXQpLnRvQmVEZWZpbmVkKClcclxuICAgICAgZXhwZWN0KG1vY2tTZWN1cmVTdG9yYWdlLnNldEpTT04pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdhdXRoX3VzZXInLCB1c2VyKVxyXG4gICAgfSlcclxuXHJcbiAgICBpdCgnc2hvdWxkIHVzZSBlbWFpbCBwcmVmaXggYXMgbmFtZSB3aGVuIG5hbWUgbm90IHByb3ZpZGVkJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBlbWFpbCA9ICdqb2huLmRvZUBleGFtcGxlLmNvbSdcclxuICAgICAgY29uc3QgcGFzc3dvcmQgPSAncGFzc3dvcmQxMjMnXHJcblxyXG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgYXV0aFNlcnZpY2Uuc2lnblVwKGVtYWlsLCBwYXNzd29yZClcclxuXHJcbiAgICAgIGV4cGVjdCh1c2VyLm5hbWUpLnRvQmUoJ2pvaG4uZG9lJylcclxuICAgIH0pXHJcblxyXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgc2lnbnVwIGVycm9ycycsIGFzeW5jICgpID0+IHtcclxuICAgICAgbW9ja1NlY3VyZVN0b3JhZ2Uuc2V0SlNPTi5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU3RvcmFnZSBlcnJvcicpXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBhd2FpdCBleHBlY3QoXHJcbiAgICAgICAgYXV0aFNlcnZpY2Uuc2lnblVwKCd0ZXN0QGV4YW1wbGUuY29tJywgJ3Bhc3N3b3JkMTIzJylcclxuICAgICAgKS5yZWplY3RzLnRvVGhyb3coJ1N0b3JhZ2UgZXJyb3InKVxyXG4gICAgfSlcclxuICB9KVxyXG5cclxuICBkZXNjcmliZSgnc2lnbkluJywgKCkgPT4ge1xyXG4gICAgaXQoJ3Nob3VsZCBhdXRoZW50aWNhdGUgdXNlciB3aXRoIHZhbGlkIGNyZWRlbnRpYWxzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBlbWFpbCA9ICd0ZXN0QGV4YW1wbGUuY29tJ1xyXG4gICAgICBjb25zdCBwYXNzd29yZCA9ICdwYXNzd29yZDEyMydcclxuXHJcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBhdXRoU2VydmljZS5zaWduSW4oZW1haWwsIHBhc3N3b3JkKVxyXG5cclxuICAgICAgZXhwZWN0KHVzZXIpLnRvTWF0Y2hPYmplY3Qoe1xyXG4gICAgICAgIGVtYWlsLFxyXG4gICAgICAgIG5hbWU6ICd0ZXN0JyxcclxuICAgICAgICByb2xlOiAndXNlcicsXHJcbiAgICAgIH0pXHJcbiAgICAgIGV4cGVjdCh1c2VyLmxhc3RMb2dpbikudG9CZURlZmluZWQoKVxyXG4gICAgICBleHBlY3QoYXV0aFNlcnZpY2UuaXNBdXRoZW50aWNhdGVkKCkpLnRvQmUodHJ1ZSlcclxuICAgIH0pXHJcblxyXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgc2lnbmluIGVycm9ycycsIGFzeW5jICgpID0+IHtcclxuICAgICAgLy8gTW9jayBsb2NhbFN0b3JhZ2UgdG8gdGhyb3cgZXJyb3JcclxuICAgICAgY29uc3Qgb3JpZ2luYWxTZXRJdGVtID0gU3RvcmFnZS5wcm90b3R5cGUuc2V0SXRlbVxyXG4gICAgICBTdG9yYWdlLnByb3RvdHlwZS5zZXRJdGVtID0gamVzdC5mbigoKSA9PiB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdG9yYWdlIGVycm9yJylcclxuICAgICAgfSlcclxuXHJcbiAgICAgIGF3YWl0IGV4cGVjdChcclxuICAgICAgICBhdXRoU2VydmljZS5zaWduSW4oJ3Rlc3RAZXhhbXBsZS5jb20nLCAncGFzc3dvcmQxMjMnKVxyXG4gICAgICApLnJlamVjdHMudG9UaHJvdygnU3RvcmFnZSBlcnJvcicpXHJcblxyXG4gICAgICBTdG9yYWdlLnByb3RvdHlwZS5zZXRJdGVtID0gb3JpZ2luYWxTZXRJdGVtXHJcbiAgICB9KVxyXG4gIH0pXHJcblxyXG4gIGRlc2NyaWJlKCdzaWduT3V0JywgKCkgPT4ge1xyXG4gICAgaXQoJ3Nob3VsZCBjbGVhciB1c2VyIHNlc3Npb24nLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIC8vIEZpcnN0IHNpZ24gaW5cclxuICAgICAgYXdhaXQgYXV0aFNlcnZpY2Uuc2lnbkluKCd0ZXN0QGV4YW1wbGUuY29tJywgJ3Bhc3N3b3JkMTIzJylcclxuICAgICAgZXhwZWN0KGF1dGhTZXJ2aWNlLmlzQXV0aGVudGljYXRlZCgpKS50b0JlKHRydWUpXHJcblxyXG4gICAgICAvLyBUaGVuIHNpZ24gb3V0XHJcbiAgICAgIGF3YWl0IGF1dGhTZXJ2aWNlLnNpZ25PdXQoKVxyXG5cclxuICAgICAgZXhwZWN0KGF1dGhTZXJ2aWNlLmlzQXV0aGVudGljYXRlZCgpKS50b0JlKGZhbHNlKVxyXG4gICAgICBleHBlY3QoYXV0aFNlcnZpY2UuZ2V0Q3VycmVudFVzZXIoKSkudG9CZU51bGwoKVxyXG4gICAgICBleHBlY3QobW9ja1NlY3VyZVN0b3JhZ2UucmVtb3ZlSXRlbSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2F1dGhfdXNlcicpXHJcbiAgICB9KVxyXG4gIH0pXHJcblxyXG4gIGRlc2NyaWJlKCd1cGRhdGVQcm9maWxlJywgKCkgPT4ge1xyXG4gICAgaXQoJ3Nob3VsZCB1cGRhdGUgdXNlciBwcm9maWxlIHdoZW4gYXV0aGVudGljYXRlZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgLy8gRmlyc3Qgc2lnbiBpblxyXG4gICAgICBhd2FpdCBhdXRoU2VydmljZS5zaWduSW4oJ3Rlc3RAZXhhbXBsZS5jb20nLCAncGFzc3dvcmQxMjMnKVxyXG5cclxuICAgICAgY29uc3QgdXBkYXRlcyA9IHsgbmFtZTogJ1VwZGF0ZWQgTmFtZScsIHJvbGU6ICdhZG1pbicgfVxyXG4gICAgICBjb25zdCB1cGRhdGVkVXNlciA9IGF3YWl0IGF1dGhTZXJ2aWNlLnVwZGF0ZVByb2ZpbGUodXBkYXRlcylcclxuXHJcbiAgICAgIGV4cGVjdCh1cGRhdGVkVXNlci5uYW1lKS50b0JlKCdVcGRhdGVkIE5hbWUnKVxyXG4gICAgICBleHBlY3QodXBkYXRlZFVzZXIucm9sZSkudG9CZSgnYWRtaW4nKVxyXG4gICAgICBleHBlY3QobW9ja1NlY3VyZVN0b3JhZ2Uuc2V0SlNPTikudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2F1dGhfdXNlcicsIHVwZGF0ZWRVc2VyKVxyXG4gICAgfSlcclxuXHJcbiAgICBpdCgnc2hvdWxkIHRocm93IGVycm9yIHdoZW4gbm90IGF1dGhlbnRpY2F0ZWQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHVwZGF0ZXMgPSB7IG5hbWU6ICdVcGRhdGVkIE5hbWUnIH1cclxuXHJcbiAgICAgIGF3YWl0IGV4cGVjdChcclxuICAgICAgICBhdXRoU2VydmljZS51cGRhdGVQcm9maWxlKHVwZGF0ZXMpXHJcbiAgICAgICkucmVqZWN0cy50b1Rocm93KCdObyBhdXRoZW50aWNhdGVkIHVzZXInKVxyXG4gICAgfSlcclxuICB9KVxyXG5cclxuICBkZXNjcmliZSgnaGFzUm9sZScsICgpID0+IHtcclxuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgYWRtaW4gcm9sZSBoaWVyYXJjaHknLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGFkbWluVXNlcjogQXV0aFVzZXIgPSB7XHJcbiAgICAgICAgaWQ6ICcxJyxcclxuICAgICAgICBlbWFpbDogJ2FkbWluQGV4YW1wbGUuY29tJyxcclxuICAgICAgICBuYW1lOiAnQWRtaW4gVXNlcicsXHJcbiAgICAgICAgcm9sZTogJ2FkbWluJyxcclxuICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTW9jayB0aGUgdXNlclxyXG4gICAgICBtb2NrU2VjdXJlU3RvcmFnZS5nZXRKU09OLm1vY2tSZXR1cm5WYWx1ZShhZG1pblVzZXIpXHJcbiAgICAgIGF1dGhTZXJ2aWNlLmluaXQoKVxyXG5cclxuICAgICAgZXhwZWN0KGF1dGhTZXJ2aWNlLmhhc1JvbGUoJ2FkbWluJykpLnRvQmUodHJ1ZSlcclxuICAgICAgZXhwZWN0KGF1dGhTZXJ2aWNlLmhhc1JvbGUoJ2FnZW50JykpLnRvQmUodHJ1ZSlcclxuICAgICAgZXhwZWN0KGF1dGhTZXJ2aWNlLmhhc1JvbGUoJ3VzZXInKSkudG9CZSh0cnVlKVxyXG4gICAgfSlcclxuXHJcbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIGFnZW50IHJvbGUgaGllcmFyY2h5JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBhd2FpdCBhdXRoU2VydmljZS5zaWduSW4oJ2FnZW50QGV4YW1wbGUuY29tJywgJ3Bhc3N3b3JkMTIzJylcclxuICAgICAgYXdhaXQgYXV0aFNlcnZpY2UudXBkYXRlUHJvZmlsZSh7IHJvbGU6ICdhZ2VudCcgfSlcclxuXHJcbiAgICAgIGV4cGVjdChhdXRoU2VydmljZS5oYXNSb2xlKCdhZG1pbicpKS50b0JlKGZhbHNlKVxyXG4gICAgICBleHBlY3QoYXV0aFNlcnZpY2UuaGFzUm9sZSgnYWdlbnQnKSkudG9CZSh0cnVlKVxyXG4gICAgICBleHBlY3QoYXV0aFNlcnZpY2UuaGFzUm9sZSgndXNlcicpKS50b0JlKHRydWUpXHJcbiAgICB9KVxyXG5cclxuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgdXNlciByb2xlIGhpZXJhcmNoeScsIGFzeW5jICgpID0+IHtcclxuICAgICAgYXdhaXQgYXV0aFNlcnZpY2Uuc2lnbkluKCd1c2VyQGV4YW1wbGUuY29tJywgJ3Bhc3N3b3JkMTIzJylcclxuXHJcbiAgICAgIGV4cGVjdChhdXRoU2VydmljZS5oYXNSb2xlKCdhZG1pbicpKS50b0JlKGZhbHNlKVxyXG4gICAgICBleHBlY3QoYXV0aFNlcnZpY2UuaGFzUm9sZSgnYWdlbnQnKSkudG9CZShmYWxzZSlcclxuICAgICAgZXhwZWN0KGF1dGhTZXJ2aWNlLmhhc1JvbGUoJ3VzZXInKSkudG9CZSh0cnVlKVxyXG4gICAgfSlcclxuXHJcbiAgICBpdCgnc2hvdWxkIHJldHVybiBmYWxzZSB3aGVuIG5vdCBhdXRoZW50aWNhdGVkJywgKCkgPT4ge1xyXG4gICAgICBleHBlY3QoYXV0aFNlcnZpY2UuaGFzUm9sZSgndXNlcicpKS50b0JlKGZhbHNlKVxyXG4gICAgfSlcclxuICB9KVxyXG5cclxuICBkZXNjcmliZSgnZ2V0QWNjZXNzVG9rZW4nLCAoKSA9PiB7XHJcbiAgICBpdCgnc2hvdWxkIHJldHVybiB0b2tlbiB3aGVuIGF1dGhlbnRpY2F0ZWQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGF3YWl0IGF1dGhTZXJ2aWNlLnNpZ25JbigndGVzdEBleGFtcGxlLmNvbScsICdwYXNzd29yZDEyMycpXHJcblxyXG4gICAgICBjb25zdCB0b2tlbiA9IGF1dGhTZXJ2aWNlLmdldEFjY2Vzc1Rva2VuKClcclxuICAgICAgZXhwZWN0KHRva2VuKS50b0JlKCdtb2NrX2FjY2Vzc190b2tlbicpXHJcbiAgICB9KVxyXG5cclxuICAgIGl0KCdzaG91bGQgcmV0dXJuIG51bGwgd2hlbiBub3QgYXV0aGVudGljYXRlZCcsICgpID0+IHtcclxuICAgICAgY29uc3QgdG9rZW4gPSBhdXRoU2VydmljZS5nZXRBY2Nlc3NUb2tlbigpXHJcbiAgICAgIGV4cGVjdCh0b2tlbikudG9CZU51bGwoKVxyXG4gICAgfSlcclxuICB9KVxyXG5cclxuICBkZXNjcmliZSgnc3RhdGUgbWFuYWdlbWVudCcsICgpID0+IHtcclxuICAgIGl0KCdzaG91bGQgbm90aWZ5IHN1YnNjcmliZXJzIG9mIHN0YXRlIGNoYW5nZXMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IG1vY2tDYWxsYmFjayA9IGplc3QuZm4oKVxyXG4gICAgICBjb25zdCB1bnN1YnNjcmliZSA9IGF1dGhTZXJ2aWNlLnN1YnNjcmliZShtb2NrQ2FsbGJhY2spXHJcblxyXG4gICAgICBhd2FpdCBhdXRoU2VydmljZS5zaWduSW4oJ3Rlc3RAZXhhbXBsZS5jb20nLCAncGFzc3dvcmQxMjMnKVxyXG5cclxuICAgICAgLy8gRW5zdXJlIGNhbGxiYWNrIHdhcyBjYWxsZWQgd2l0aCB0aGUgZXhwZWN0ZWQgaW5pdGlhbCBhbmQgdXBkYXRlZCBzdGF0ZXNcclxuICAgICAgZXhwZWN0KG1vY2tDYWxsYmFjaykudG9IYXZlQmVlbkNhbGxlZCgpXHJcblxyXG4gICAgICB1bnN1YnNjcmliZSgpXHJcbiAgICB9KVxyXG5cclxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHVuc3Vic2NyaWJlIHdpdGhvdXQgZXJyb3JzJywgKCkgPT4ge1xyXG4gICAgICBjb25zdCBtb2NrQ2FsbGJhY2sgPSBqZXN0LmZuKClcclxuICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSBhdXRoU2VydmljZS5zdWJzY3JpYmUobW9ja0NhbGxiYWNrKVxyXG5cclxuICAgICAgdW5zdWJzY3JpYmUoKVxyXG4gICAgICAvLyBTaG91bGQgbm90IHRocm93XHJcbiAgICAgIGV4cGVjdCh0cnVlKS50b0JlKHRydWUpXHJcbiAgICB9KVxyXG4gIH0pXHJcbn0pIl0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwic2VjdXJlU3RvcmFnZSIsInNldEpTT04iLCJmbiIsImdldEpTT04iLCJyZW1vdmVJdGVtIiwic2V0SXRlbVNlY3VyZSIsInNldFNlY3VyZUpTT04iLCJnZXRTZWN1cmVKU09OIiwicmVtb3ZlU2VjdXJlSXRlbSIsInNldFNlY3VyZUl0ZW1BZHZhbmNlZCIsInNldFNlY3VyZUl0ZW0iLCJnZXRTZWN1cmVJdGVtIiwic2V0U2VjdXJlSlNPTkFkdmFuY2VkIiwiZ2V0U2VjdXJlSlNPTkFkdmFuY2VkIiwibW9ja1NlY3VyZVN0b3JhZ2UiLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwiYXV0aFNlcnZpY2UiLCJzaWduT3V0IiwiaXQiLCJlbWFpbCIsInBhc3N3b3JkIiwidXNlckRhdGEiLCJuYW1lIiwidXNlciIsInNpZ25VcCIsImV4cGVjdCIsInRvTWF0Y2hPYmplY3QiLCJyb2xlIiwiaWQiLCJ0b0JlRGVmaW5lZCIsImNyZWF0ZWRBdCIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwidG9CZSIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsIkVycm9yIiwicmVqZWN0cyIsInRvVGhyb3ciLCJzaWduSW4iLCJsYXN0TG9naW4iLCJpc0F1dGhlbnRpY2F0ZWQiLCJvcmlnaW5hbFNldEl0ZW0iLCJTdG9yYWdlIiwicHJvdG90eXBlIiwic2V0SXRlbSIsImdldEN1cnJlbnRVc2VyIiwidG9CZU51bGwiLCJ1cGRhdGVzIiwidXBkYXRlZFVzZXIiLCJ1cGRhdGVQcm9maWxlIiwiYWRtaW5Vc2VyIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwibW9ja1JldHVyblZhbHVlIiwiaW5pdCIsImhhc1JvbGUiLCJ0b2tlbiIsImdldEFjY2Vzc1Rva2VuIiwibW9ja0NhbGxiYWNrIiwidW5zdWJzY3JpYmUiLCJzdWJzY3JpYmUiLCJ0b0hhdmVCZWVuQ2FsbGVkIl0sIm1hcHBpbmdzIjoiO0FBR0EscUJBQXFCO0FBQ3JCQSxLQUFLQyxJQUFJLENBQUMsNkJBQTZCO0lBQ3JDLE1BQU1DLGdCQUFnQjtRQUNwQkMsU0FBU0gsS0FBS0ksRUFBRTtRQUNoQkMsU0FBU0wsS0FBS0ksRUFBRTtRQUNoQkUsWUFBWU4sS0FBS0ksRUFBRTtJQUNyQjtJQUNBLE1BQU1HLGdCQUFnQlAsS0FBS0ksRUFBRTtJQUM3QixPQUFPO1FBQ0xGO1FBQ0Esd0VBQXdFO1FBQ3hFTSxlQUFlTixjQUFjQyxPQUFPO1FBQ3BDTSxlQUFlUCxjQUFjRyxPQUFPO1FBQ3BDSyxrQkFBa0JSLGNBQWNJLFVBQVU7UUFDMUNLLHVCQUF1Qko7UUFDdkJLLGVBQWVaLEtBQUtJLEVBQUU7UUFDdEJTLGVBQWViLEtBQUtJLEVBQUU7UUFDdEJVLHVCQUF1QlosY0FBY0MsT0FBTztRQUM1Q1ksdUJBQXVCYixjQUFjRyxPQUFPO0lBQzlDO0FBQ0Y7Ozs7c0JBdkJzQzsrQkFDUjtBQXdCOUIsTUFBTVcsb0JBQW9CZCw0QkFBYTtBQUV2Q2UsU0FBUyxlQUFlO0lBQ3RCQyxXQUFXO1FBQ1RsQixLQUFLbUIsYUFBYTtRQUNsQiwyQkFBMkI7UUFDM0JDLGlCQUFXLENBQUNDLE9BQU87SUFDckI7SUFFQUosU0FBUyxVQUFVO1FBQ2pCSyxHQUFHLG9DQUFvQztZQUNyQyxNQUFNQyxRQUFRO1lBQ2QsTUFBTUMsV0FBVztZQUNqQixNQUFNQyxXQUFXO2dCQUFFQyxNQUFNO1lBQVk7WUFFckMsTUFBTUMsT0FBTyxNQUFNUCxpQkFBVyxDQUFDUSxNQUFNLENBQUNMLE9BQU9D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